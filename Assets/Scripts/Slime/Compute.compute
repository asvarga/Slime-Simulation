

struct FrogData {
    // USER DEFINED
    uint state;
};
struct Frog {
    int2 position;
    FrogData data;
};
struct FrogMail {
    // USER DEFINED
    bool tag;
    int2 position;
};

typedef float4 PixelData;
typedef int3 PixelMail;

////////////////////////////////////////////////////////////////

float time;
float deltaTime;

uint numFrogs;
RWStructuredBuffer<Frog> frogs;
RWStructuredBuffer<FrogMail> frogMail;

int width;
int height;
RWTexture2D<PixelData> pixels;
RWTexture2D<PixelMail> pixelMail;

RWTexture2D<float4> display;

////////////////////////////////////////////////////////////////

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

////////////////////////////////////////////////////////////////

// 0
#pragma kernel FrogInit
// W    frogs

[numthreads(16,1,1)]
void FrogInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = int2(id.x/32+200, id.x%32+200);
    frogs[id.x].position = pos;     // move frog
    // TODO:
    // pixels[pos].x = 1;              // mark occupied
}

////////////////////////////////////////////////////////////////

// 1
#pragma kernel FrogDisplay
// R    frogs
// W    display

[numthreads(16,1,1)]
void FrogDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    display[pos] = float4(1, 1, 1, 1);
}

////////////////////////////////////////////////////////////////

// 2
#pragma kernel FrogAct
// R    frogs
// W    frogMail

[numthreads(16,1,1)]
void FrogAct (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;

    uint random = hash(id.x + time * 100000);

    switch (random % 4) {
        case 0: pos.x++; break;
        case 1: pos.x--; break;
        case 2: pos.y++; break;
        case 3: pos.y--; break;
    }

    // frogs[id.x].position = pos;
    frogMail[id.x].position = pos;

    // TODO:
    // if (pixels[pos].x == 0) {       // if spot open
    //     pixelMail[pos].x = id.x;                // mail own id
    //     InterlockedAdd(pixelMail[pos].y, 1);    // increase mail counter
    // }
}

////////////////////////////////////////////////////////////////

// 3
#pragma kernel FrogResolve
// RC   frogMail
// W    frogs

[numthreads(16,1,1)]
void FrogResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogMail[id.x].position;
    frogs[id.x].position = pos;
}

////////////////////////////////////////////////////////////////

// // 4
// #pragma kernel SquareResolve
// // RC   pixelMail
// // W    pixels
// // W    frogs   

// [numthreads(8,8,1)]
// void SquareResolve (uint3 id : SV_DispatchThreadID)
// {
// 	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
// 		return;
// 	}

//     int frogId = pixelMail[id.xy].x;
//     int count = pixelMail[id.xy].y;

//     if (count == 1) {
//         int2 oldPos = frogs[frogId].position;
//         frogs[frogId].position = id.xy; // move frog
//         pixels[oldPos].x = 0;           // mark unoccupied
//         pixels[pos].y = 0;              // mark occupied
//     }

//     pixelMail[id.xy] = int2();  // clear mail
// }


// // n
// #pragma kernel PixelDisplay

////////////////////////////////////////////////////////////////

