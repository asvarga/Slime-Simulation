

/*
- We go to great lengths to avoid race conditions
- Each kernel annotates its reference capabilites to the various buffers
    - (R)ead, (W)rite, (C)lear, (A)tomic Update
- A kernel can only have R+W to a buffer if it has 1-to-1 ownship
    - i.e. no reading or writing of other values

- <USER></USER> tags mark user owned code
    - i.e. where foreign code might be sliced in
*/

struct FrogData {
    // <USER>
    uint dir;
    bool debug;
    bool flip;
    // </USER>
};
struct Frog {
    int2 position;
    uint status;
    FrogData data;
};
struct FrogMail {
    // <USER>
    bool tag;
    int2 position;
    // FrogData data;
    // </USER>
};

struct Pixel {
    uint occupant;
    bool collision;
};
struct PixelMail {
    int count;
};

////////////////////////////////////////////////////////////////

float time;
float deltaTime;
int tick;

uint numFrogs;
RWStructuredBuffer<Frog> frogs;
RWStructuredBuffer<FrogMail> frogMail;

int width;
int height;
RWStructuredBuffer<Pixel> pixels;
RWStructuredBuffer<PixelMail> pixelMail;

RWTexture2D<float4> display;

////////////////////////////////////////////////////////////////

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

uint index(int2 pos) {
    return pos.y * width + pos.x;
}

int2 position(uint ind) {
    return int2(ind % width, ind / width);
}

bool inBounds(int2 pos) {
    return (pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y < height);
}

bool legal(int2 pos) {
    // if (pos.x < 0 || pos.x >= width || pos.y < 0 || pos.y >= height) return false;
    // if (!inBounds(pos)) return false;
    // int ind = index(pos);
    // return pixels[ind].occupant == -1;
    return inBounds(pos) && pixels[index(pos)].occupant == -1;
}

int2 move(int2 pos, uint dir) {
    switch (dir) {
        case 0: pos.x++; break;
        case 1: pos.y++; break;
        case 2: pos.x--; break;
        case 3: pos.y--; break;
    }
    return pos;
}

bool eq(int2 p1, int2 p2) {
    return p1.x == p2.x && p1.y == p2.y;
}

////////////////////////////////////////////////////////////////

// 0
#pragma kernel FrogInit
// W    frogs
// W    pixels

[numthreads(16,1,1)]
void FrogInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    frogs[id.x] = (Frog)0;
    frogMail[id.x] = (FrogMail)0;

    uint s = sqrt(numFrogs);
    int2 pos = int2(id.x/s+(width>>1)-s/2, id.x%s+(height>>1)-s/2);
    frogs[id.x].position = pos;         // move frog
    int ind = index(pos);
    pixels[ind].occupant = id.x;        // set occupant

    FrogData data = frogs[id.x].data;

    // <USER>
    // user should mutate data

    // data.dir = 0;
    data.dir = pos.x >= width>>1 ? (pos.y >= height>>1 ? 0 : 3) : (pos.y >= height>>1 ? 1 : 2);
    // data.dir = hash(id.x + hash(tick)) % 4; 
    // data.dir = (pos.x*2 + pos.y) % 4;

    // data.flip = true;

    // </USER>

    frogs[id.x].data = data;
}

////////////////////////////////////////////////////////////////

// 1
#pragma kernel FrogDisplay
// R    frogs
// W    display

[numthreads(16,1,1)]
void FrogDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    float4 color = float4(0,0,0,1);
    FrogData data = frogs[id.x].data;

    // <USER>

    // int ind = index(pos);
    // if (ind >= 0 && pixels[ind].occupant != id.x) {
    //     color = float4(1,0.5,0,1); 
    //     return;
    // }
    // switch (data.dir) {
    //     case 0: color = float4(1,0,0,1); break;
    //     case 1: color = float4(1,1,0,1); break;
    //     case 2: color = float4(0,1,0,1); break;
    //     case 3: color = float4(0,1,1,1); break;
    // }
    color = data.flip ? float4(1,0,0,1) : float4(0,1,0,1);
    // color = float4(0,1,0,1);
    // color = data.debug ? float4(1,0,0,1) : float4(0,1,0,1);

    // </USER>

    display[pos] = color;
}

////////////////////////////////////////////////////////////////

// 2
#pragma kernel FrogAct
// RW   frogs
// W    frogMail
// R    pixels
// A    pixelMail

[numthreads(16,1,1)]
void FrogAct (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    FrogData data = frogs[id.x].data;
    uint status = frogs[id.x].status;

    // <USER>
    // user should mutate data and pos

    if (hash(id.x + hash(tick)) % 1000 == 0) {
        data.flip = !data.flip;
    }
    // data.flip = !data.flip;

    // if (eq(pos, data.prevPos)) {  // failed to move
    if (status != 1) {  // collided
        // data.dir = hash(id.x + hash(tick)) % 4;  // random new direction
        int turn = data.flip ? 3 : 1;
        data.dir = (data.dir + turn) % 4;  // turn 90 deg
        data.debug = true;
    } else {
        data.debug = false;
    }
    // data.prevPos = pos;
    int2 prevPos = pos;
    pos = move(prevPos, data.dir);
    if (!inBounds(pos)) {
        data.dir = (data.dir + 2) % 4;  // turn 180 deg
        pos = move(prevPos, data.dir);
    }

    // </USER>

    frogs[id.x].data = data;    // FIXME: is this not working?

    // TODO: also check adjacency
    if (legal(pos)) {               // unoccupied
        int ind = index(pos);
        frogMail[id.x].position = pos;
        InterlockedAdd(pixelMail[ind].count, 1);    // atomically increase mail counter
    } else {
        frogMail[id.x].position = pos;
        frogs[id.x].status == -1;
    }

    // frogMail[id.x].data = data;
}

////////////////////////////////////////////////////////////////

// 3
#pragma kernel FrogResolve
// R    frogMail
// R    pixelMail
// W    frogs
// W    pixels

[numthreads(16,1,1)]
void FrogResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    // frogs[id.x].data = frogMail[id.x].data;

    int2 oldPos = frogs[id.x].position;
    int2 newPos = frogMail[id.x].position;
    if (eq(oldPos, newPos)) return;
    int oldInd = index(oldPos);
    int newInd = index(newPos);

    int count = pixelMail[newInd].count;    // get count

    // we can assume that if this pixel is occupied => count == 0
    pixels[newInd].collision = (count > 1);
    frogs[id.x].status = count;
    if (count != 1) return;                 // inactive/conflicts
    
    frogs[id.x].position = newPos;          // move frog
    pixels[oldInd].occupant = -1;           // clear occupant
    pixels[newInd].occupant = id.x;         // set occupant
}

////////////////////////////////////////////////////////////////

// 4
#pragma kernel PixelResolve
// RC   pixelMail
// W    pixels
// W    frogs   

[numthreads(8,8,1)]
void PixelResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    pixelMail[ind].count = 0;               // clear count (KEEP)
}


////////////////////////////////////////////////////////////////

// 5
#pragma kernel PixelInit
// W    pixels 

[numthreads(8,8,1)]
void PixelInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    pixels[ind] = (Pixel)0;
    pixelMail[ind] = (PixelMail)0;

    pixels[ind].occupant = -1;
}

////////////////////////////////////////////////////////////////


// 6
#pragma kernel PixelDisplay
// R    pixels
// W    display

[numthreads(8,8,1)]
void PixelDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    bool occupied = (pixels[ind].occupant != -1);
    // bool collision = pixels[ind].collision;
    // display[pos] = float4(0,0,0,1);
    display[pos] = occupied ? float4(1,1,1,1) 
                            : float4(0,0,0,1);
                            // : (collision ? float4(1,0,0,1) 
                                        //  : float4(0,0,0,1));
}

////////////////////////////////////////////////////////////////

