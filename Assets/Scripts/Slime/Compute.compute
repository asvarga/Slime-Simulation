

struct FrogData {
    // USER DEFINED
    uint state;
};
struct Frog {
    int2 position;
    FrogData data;
};
struct FrogMail {
    // USER DEFINED
    bool tag;
    int2 position;
};

struct Pixel {
    int occupant;
    bool collision;
};
struct PixelMail {
    int occupant;
    int count;
};

////////////////////////////////////////////////////////////////

float time;
float deltaTime;

uint numFrogs;
RWStructuredBuffer<Frog> frogs;
RWStructuredBuffer<FrogMail> frogMail;

uint width;
uint height;
RWStructuredBuffer<Pixel> pixels;
RWStructuredBuffer<PixelMail> pixelMail;

RWTexture2D<float4> display;

////////////////////////////////////////////////////////////////

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

uint index(int2 pos) {
    return pos.y * width + pos.x;
}

int2 position(uint ind) {
    return int2(ind % width, ind / width);
}

////////////////////////////////////////////////////////////////

// 0
#pragma kernel FrogInit
// W    frogs

[numthreads(16,1,1)]
void FrogInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    uint s = sqrt(numFrogs);
    int2 pos = int2(id.x/s+width/2-s/2, id.x%s+height/2-s/2);
    frogs[id.x].position = pos;         // move frog
    int ind = index(pos);
    pixels[ind].occupant = id.x;        // set occupant
}

////////////////////////////////////////////////////////////////

// 1
#pragma kernel FrogDisplay
// R    frogs
// W    display

[numthreads(16,1,1)]
void FrogDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    // display[pos] = float4(1, 1, 1, 1);
}

////////////////////////////////////////////////////////////////

// 2
#pragma kernel FrogAct
// R    frogs
// W    frogMail

[numthreads(16,1,1)]
void FrogAct (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;

    uint random = hash(id.x + time * 100000);

    switch (random % 4) {
        case 0: pos.x++; break;
        case 1: pos.x--; break;
        case 2: pos.y++; break;
        case 3: pos.y--; break;
    }

    // frogs[id.x].position = pos;
    // frogMail[id.x].position = pos;

    int ind = index(pos);
    if (pixels[ind].occupant == -1) {               // unoccupied
        pixelMail[ind].occupant = id.x;             // mail own id
        InterlockedAdd(pixelMail[ind].count, 1);    // increase mail counter
    }
}

////////////////////////////////////////////////////////////////

// 3
#pragma kernel FrogResolve
// RC   frogMail
// W    frogs

[numthreads(16,1,1)]
void FrogResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogMail[id.x].position;
    // frogs[id.x].position = pos;
}

////////////////////////////////////////////////////////////////

// 4
#pragma kernel PixelResolve
// RC   pixelMail
// W    pixels
// W    frogs   

[numthreads(8,8,1)]
void PixelResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    int count = pixelMail[ind].count;       // get count
    pixelMail[ind].count = 0;               // clear count

    // we can assume that if this pixel is occupied => count == 0
    pixels[ind].collision = (count > 1);
    if (count != 1) return;                 // inactive/conflicts

    int occupant = pixelMail[ind].occupant;
    int2 oldPos = frogs[occupant].position;
    int oldInd = index(oldPos);
    
    frogs[occupant].position = pos;         // move frog
    pixels[oldInd].occupant = -1;           // clear occupant
    pixels[ind].occupant = occupant;        // set occupant
}


////////////////////////////////////////////////////////////////

// 5
#pragma kernel PixelInit
// W    pixels 
// W    pixelMail

[numthreads(8,8,1)]
void PixelInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    pixels[ind].occupant = -1;
    pixelMail[ind].occupant = -1;
}

////////////////////////////////////////////////////////////////


// 6
#pragma kernel PixelDisplay
// R    pixels
// W    display

[numthreads(8,8,1)]
void PixelDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    bool occupied = (pixels[ind].occupant != -1);
    bool collision = pixels[ind].collision;
    display[pos] = occupied ? float4(0,1,0,1) 
                            : (collision ? float4(1,0,0,1) 
                                         : float4(0,0,0,1));
}

////////////////////////////////////////////////////////////////

