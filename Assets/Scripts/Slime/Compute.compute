

/*
- We go to great lengths to avoid race conditions
- Each kernel annotates its reference capabilites to the various buffers
    - (R)ead, (W)rite, (C)lear, (A)tomic Update
- A kernel can only have R+W to a buffer if it has 1-to-1 ownship
    - i.e. no reading or writing of other values

- <USER></USER> tags mark user owned code
    - i.e. where foreign code might be sliced in
*/

struct FrogData {
    // <USER>
    uint dir;
    bool debug;
    int2 prevPos;
    // </USER>
};
struct Frog {
    int2 position;
    FrogData data;
};
struct FrogMail {
    // <USER>
    bool tag;
    int2 position;
    // FrogData data;
    // </USER>
};

struct Pixel {
    uint occupant;
    bool collision;
};
struct PixelMail {
    uint occupant;
    int count;
};

////////////////////////////////////////////////////////////////

float time;
float deltaTime;

uint numFrogs;
RWStructuredBuffer<Frog> frogs;
RWStructuredBuffer<FrogMail> frogMail;

int width;
int height;
RWStructuredBuffer<Pixel> pixels;
RWStructuredBuffer<PixelMail> pixelMail;

RWTexture2D<float4> display;

////////////////////////////////////////////////////////////////

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

uint index(int2 pos) {
    return pos.y * width + pos.x;
}

int2 position(uint ind) {
    return int2(ind % width, ind / width);
}

////////////////////////////////////////////////////////////////

// 0
#pragma kernel FrogInit
// W    frogs
// W    pixels

[numthreads(16,1,1)]
void FrogInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    uint s = sqrt(numFrogs);
    int2 pos = int2(id.x/s+(uint)width/2-s/2, id.x%s+(uint)height/2-s/2);
    frogs[id.x].position = pos;         // move frog
    int ind = index(pos);
    pixels[ind].occupant = id.x;        // set occupant

    FrogData data = frogs[id.x].data;

    // <USER>
    // user should mutate data

    data.dir = 0;
    // data.dir = hash(id.x + hash(time * 1000)) % 4; 
    // data.dir = (pos.x*2 + pos.y) % 4;

    // </USER>

    frogs[id.x].data = data;
}

////////////////////////////////////////////////////////////////

// 1
#pragma kernel FrogDisplay
// R    frogs
// W    display

[numthreads(16,1,1)]
void FrogDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    switch (frogs[id.x].data.dir) {
        case 0: display[pos] = float4(1,0,0,1); break;
        case 1: display[pos] = float4(1,1,0,1); break;
        case 2: display[pos] = float4(0,1,0,1); break;
        case 3: display[pos] = float4(0,1,1,1); break;
    }
    // display[pos] = frogs[id.x].data.debug ? float4(1,0,0,1) : float4(0,1,0,1);
}

////////////////////////////////////////////////////////////////

// 2
#pragma kernel FrogAct
// RW   frogs
// W    frogMail
// R    pixels
// A    pixelMail

bool inBounds(int2 pos) {
    return (pos.x >= 0 && pos.y < width && pos.y >= 0 && pos.y < height);
}

bool legal(int2 pos) {
    // if (pos.x < 0 || pos.x >= width || pos.y < 0 || pos.y >= height) return false;
    // if (!inBounds(pos)) return false;
    // int ind = index(pos);
    // return pixels[ind].occupant == -1;
    return inBounds(pos) && pixels[index(pos)].occupant == -1;
}

int2 move(int2 pos, uint dir) {
    switch (dir) {
        case 0: pos.x++; break;
        case 1: pos.y++; break;
        case 2: pos.x--; break;
        case 3: pos.y--; break;
    }
    return pos;
}

bool eq(int2 p1, int2 p2) {
    return p1.x == p2.x && p1.y == p2.y;
}

[numthreads(16,1,1)]
void FrogAct (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    int2 pos = frogs[id.x].position;
    FrogData data = frogs[id.x].data;

    // <USER>
    // user should mutate data and pos

    if (eq(pos, data.prevPos)) {  // failed to move
        // data.dir = hash(id.x + hash(time * 1000)) % 4;  // random new direction
        data.dir = (data.dir + 1) % 4;  // turn 90 deg
        data.debug = true;
    } else {
        data.debug = false;
    }
    data.prevPos = pos;
    pos = move(data.prevPos, data.dir);
    if (!inBounds(pos)) {
        data.dir = (data.dir + 2) % 4;  // turn 180 deg
        pos = move(data.prevPos, data.dir);
    }

    // </USER>

    frogs[id.x].data = data;

    // TODO: also check adjacency
    if (legal(pos)) {               // unoccupied
        int ind = index(pos);
        pixelMail[ind].occupant = id.x;             // mail own id
        InterlockedAdd(pixelMail[ind].count, 1);    // increase mail counter
    }

    // frogMail[id.x].data = data;
}

////////////////////////////////////////////////////////////////

// 3
#pragma kernel FrogResolve
// RC   frogMail
// W    frogs

[numthreads(16,1,1)]
void FrogResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numFrogs) {
		return;
	}

    // int2 pos = frogMail[id.x].position;
    // frogs[id.x].data = frogMail[id.x].data;
}

////////////////////////////////////////////////////////////////

// 4
#pragma kernel PixelResolve
// RC   pixelMail
// W    pixels
// W    frogs   

[numthreads(8,8,1)]
void PixelResolve (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    int count = pixelMail[ind].count;       // get count
    pixelMail[ind].count = 0;               // clear count

    // we can assume that if this pixel is occupied => count == 0
    pixels[ind].collision = (count > 1);
    if (count != 1) return;                 // inactive/conflicts

    uint occupant = pixelMail[ind].occupant;
    int2 oldPos = frogs[occupant].position;
    int oldInd = index(oldPos);
    
    frogs[occupant].position = pos;         // move frog
    pixels[oldInd].occupant = -1;           // clear occupant
    pixels[ind].occupant = occupant;        // set occupant
}


////////////////////////////////////////////////////////////////

// 5
#pragma kernel PixelInit
// W    pixels 

[numthreads(8,8,1)]
void PixelInit (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    pixels[ind].occupant = -1;
    // pixelMail[ind].occupant = -1;
}

////////////////////////////////////////////////////////////////


// 6
#pragma kernel PixelDisplay
// R    pixels
// W    display


[numthreads(8,8,1)]
void PixelDisplay (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    int2 pos = id.xy;
    int ind = index(pos);

    bool occupied = (pixels[ind].occupant != -1);
    bool collision = pixels[ind].collision;
    display[pos] = occupied ? float4(0,1,0,1) 
                            : float4(0,0,0,1);
                            // : (collision ? float4(1,0,0,1) 
                                        //  : float4(0,0,0,1));
}

////////////////////////////////////////////////////////////////

